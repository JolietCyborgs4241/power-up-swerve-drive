// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in th future.
#include <Subsystems/Pigeon.h>
#include "DriveTrain.h"
#include "Robotmap.h"
#include "Math.h"
#include "ctre/Phoenix.h"
#include "Robot.h"

DriveTrain::DriveTrain() : Subsystem("DriveTrain") {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	frontLeftDrive = RobotMap::driveTrainFrontLeftDrive;
	frontRightDrive = RobotMap::driveTrainFrontRightDrive;
	rearLeftDrive = RobotMap::driveTrainRearLeftDrive;
	rearRightDrive = RobotMap::driveTrainRearRightDrive;
	frontLeftPos = RobotMap::driveTrainFrontLeftPos;
	frontLeftSteer = RobotMap::driveTrainFrontLeftSteer;
	frontLeft = RobotMap::driveTrainFrontLeft;
	frontRightPos = RobotMap::driveTrainFrontRightPos;
	frontRightSteer = RobotMap::driveTrainFrontRightSteer;
	frontRight = RobotMap::driveTrainFrontRight;
	rearLeftPos = RobotMap::driveTrainRearLeftPos;
	rearLeftSteer = RobotMap::driveTrainRearLeftSteer;
	rearLeft = RobotMap::driveTrainRearLeft;
	rearRightPos = RobotMap::driveTrainRearRightPos;
	rearRightSteer = RobotMap::driveTrainRearRightSteer;
	rearRight = RobotMap::driveTrainRearRight;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	FLInv = 1;
	FRInv = 1;
	RRInv = 1;
	RLInv = 1;
}
    
void DriveTrain::InitDefaultCommand() {
	// Set the default command for a subsystem here.
	//SetDefaultCommand(new MySpecialCommand());
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}
// Put methods for controlling this subsystem
// here. Call these from Commands.
void DriveTrain::SetWheelbase(float w, float x, float y) {
	W = w;
	X = x;
	Y = y;
}
void DriveTrain::SetOffsets(double FLOff, double FROff, double RLOff, double RROff) {
	FLOffset = FLOff;
	FROffset = FROff;
	RLOffset = RLOff;
	RROffset = RROff;
}
void DriveTrain::ToggleFrontBack() {
	driveFront = !driveFront;
}

void DriveTrain::Crab(float twist, float y, float x, bool useGyro) {
	float FWD = y;
	float STR = x;

	if (useGyro) {
		const double robotangle = Robot::pigeon->GetYaw() * M_PI / 180;
		FWD =  y * cos(robotangle) + x * sin(robotangle);
		STR = -y * sin(robotangle) + x * cos(robotangle);
	}

	radius = sqrt(pow(Y,2)+pow(X,2));
	
	AP = STR - twist*X/radius;
	BP = STR + twist*X/radius;
	CP = FWD - twist*Y/radius;
	DP = FWD + twist*Y/radius;
	
	float FLSetPoint = 2.5;
	float FRSetPoint = 2.5;
	float RLSetPoint = 2.5;
	float RRSetPoint = 2.5;
	
	if(DP != 0 || BP != 0)
		FLSetPoint = (1.25 + 2.5/pi*atan2(BP,DP));
	if(AP != 0 || DP != 0)
		FRSetPoint = (1.25 + 2.5/pi*atan2(AP,DP));
	if(BP != 0 || CP != 0)
		RLSetPoint = (1.25 + 2.5/pi*atan2(BP,CP));
	if(AP != 0 || CP != 0)
		RRSetPoint = (1.25 + 2.5/pi*atan2(AP,CP));
	
//    if(twist < -0.1 || twist > 0.1){
//    	FRInv = -1;
//    	RLInv = -1;
//    } else {
//    	FRInv = 1;
//    	RLInv = 1;
//    }

	//SetSteerSetpoint(FLSetPoint, FRSetPoint, RLSetPoint, RRSetPoint, true);
	SetSteerSetpoint(FLSetPoint, FRSetPoint, RLSetPoint, RRSetPoint);
	FL = sqrt(pow(BP,2)+pow(DP,2));
	FR = sqrt(pow(AP,2)+pow(DP,2));
	RL = sqrt(pow(BP,2)+pow(CP,2));
	RR = sqrt(pow(AP,2)+pow(CP,2));
	
	//Solve for fastest wheel speed
	double speedarray[] = {fabs(FL), fabs(FR), fabs(RL), fabs(RR)};
		
	 int length = 4;
     double maxspeed = speedarray[0];
     for(int i = 1; i < length; i++) {
          if(speedarray[i] > maxspeed) {
              maxspeed = speedarray[i];
          }
     }
		 
	//Set ratios based on maximum wheel speed
    if(maxspeed > 1 || maxspeed < -1) {
		FLRatio = FL/maxspeed;
		FRRatio = FR/maxspeed;
		RLRatio = RL/maxspeed;
		RRRatio = RR/maxspeed;
    } else {
		FLRatio = FL;
		FRRatio = FR;
		RLRatio = RL;
		RRRatio = RR;
    }
    
	//Set drive speeds
    SetDriveSpeed(FLRatio, FRRatio, RLRatio, RRRatio);
}

double DriveTrain::CorrectSteerSetpoint(double setpoint) {
	//Used to correct steering setpoints to within the 0 to 5 V scale 
		
	if (setpoint < 0) {
		return setpoint + 5;
	} else if (setpoint > 5) {
		return setpoint - 5;
	} else if (setpoint == 5) {
		return 0;
	} else {
		return setpoint;
	}
}


 void DriveTrain::SetSteerSetpoint(float FLSetPoint, float FRSetPoint, float RLSetPoint, float RRSetPoint) {
	 frontLeft->SetSetpoint(CorrectSteerSetpoint(FLSetPoint+FLOffset));
	 frontRight->SetSetpoint(CorrectSteerSetpoint(FRSetPoint+FROffset));
	 rearLeft->SetSetpoint(CorrectSteerSetpoint(RLSetPoint+RLOffset));
	 rearRight->SetSetpoint(CorrectSteerSetpoint(RRSetPoint+RROffset));

/*	if(fabs(FLSetPoint  - frontLeftPos->GetAverageVoltage()) < 1.25 || fabs(FLSetPoint  - frontLeftPos->GetAverageVoltage()) > 3.75)
	 {
		 frontLeft->SetSetpoint(CorrectSteerSetpoint(FLSetPoint));
		 FLInv = 1;
	 }
	 	 else
	 {
	 		frontLeft->SetSetpoint(CorrectSteerSetpoint(FLSetPoint-2.5));
	 		FLInv = -1;
	 }

	 if(fabs(FRSetPoint  - frontRightPos->GetAverageVoltage()) < 1.25 || fabs(FRSetPoint  - frontRightPos->GetAverageVoltage()) > 3.75)
	 {
	 		frontRight->SetSetpoint(CorrectSteerSetpoint(FRSetPoint));
	 		FRInv = 1;
	 }
	 	else
	 {
	 		frontRight->SetSetpoint(CorrectSteerSetpoint(FRSetPoint-2.5));
	 		FRInv = -1;


	 if(fabs(RLSetPoint  - rearLeftPos->GetAverageVoltage()) < 1.25 || fabs(RLSetPoint  - rearLeftPos->GetAverageVoltage()) > 3.75)
	 {
	 		rearLeft->SetSetpoint(CorrectSteerSetpoint(RLSetPoint));
	 		RLInv = 1;
	 }
	 	else
	 {
	 		rearLeft->SetSetpoint(CorrectSteerSetpoint(RLSetPoint-2.5));
	 		RLInv = -1;
	 }

	 if(fabs(RRSetPoint  - rearRightPos->GetAverageVoltage()) < 1.25 || fabs(RRSetPoint  - rearRightPos->GetAverageVoltage()) > 3.75)
	 {
	 		rearRight->SetSetpoint(CorrectSteerSetpoint(RRSetPoint));
	 		RRInv = 1;
	 }
	 	else
	 {
	 		rearRight->SetSetpoint(CorrectSteerSetpoint(RRSetPoint-2.5));
	 		RRInv = -1;
	}

	 }*/
}

void DriveTrain::SetDriveSpeed(float FLSpeed, float FRSpeed, float RLSpeed, float RRSpeed) {
	//applies inversion variables defined in SetSteerSetPoint function
	frontLeftDrive->Set(ControlMode::PercentOutput, FLSpeed*FLInv);
	frontRightDrive->Set(ControlMode::PercentOutput, FRSpeed*FRInv);
	rearLeftDrive->Set(ControlMode::PercentOutput, RLSpeed*RLInv);
	rearRightDrive->Set(ControlMode::PercentOutput, RRSpeed*RRInv);
}
void DriveTrain::Lock() {
	//locks wheels to prevent robot movement
	SetSteerSetpoint(2.0, 0.75, 3.25, 4.5);
	SetDriveSpeed(0,0,0,0);
}

void DriveTrain::DriveForward() {
	SetSteerSetpoint(2.5, 2.5, 2.5, 2.5);
	SetDriveSpeed(0.8, 0.8, 0.8, 0.8);
}

void DriveTrain::DriveReverse() {
	SetSteerSetpoint(0.0, 0.0, 0.0, 0.0);
	SetDriveSpeed(0.6, 0.6, 0.6, 0.6);
}

void DriveTrain::Stop(){
	SetDriveSpeed(0, 0, 0, 0);
}
